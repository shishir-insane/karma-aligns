"""
Vedic Predictions Engine (Refactored, Single-File Edition)
==========================================================

This file consolidates the core components for a production-ready Vedic
astrology prediction engine. It includes:

1) Ephemeris adapter with Swiss Ephemeris + graceful fallback
2) Input validation (DOB/TOB/TZ/Geo) and context flags
3) Vimshottari Dasha calculator (multi-level)
4) Divisional charts (D9, D10)
5) Vedic aspects (graha drishti)
6) Arudha padas scaffold
7) Transit finder (aspects + ingresses) and exact Solar Return
8) Ashtakavarga (Bhina + Sarva)
9) Varshaphal core (Muntha + Tajika aspects)
10) Yoga engine (rule DSL evaluator)
11) PredictionEngine orchestrator with high-level endpoints

Notes:
- Where Swiss Ephemeris is not available, the engine degrades gracefully
  with coarse mean-motion approximations and marks precision='coarse'.
- Ascendant computation uses Swiss Ephemeris (swe.houses) if available;
  otherwise a placeholder sign index is derived from the Sun sign as a last resort.

Environment:
- SE_EPHE_PATH or SWISSEPH_PATH can point to ephemeris files for Swiss Ephemeris.

Author: Refactor generated by ChatGPT (GPT-5 Thinking)
License: MIT (adjust as needed)
"""

from __future__ import annotations

import os
import re
import math
import json
import time
import datetime as dt
from dataclasses import dataclass
from typing import Optional, Dict, List, Tuple, Iterable, Any, Literal, Callable

# ------------------------------------------------------------
# 1) Ephemeris adapter with graceful fallback
# ------------------------------------------------------------

try:
    import swisseph as swe
    _HAS_SWE = True
except Exception:
    swe = None
    _HAS_SWE = False

PrecisionTag = Literal["high","coarse"]

@dataclass
class GeoPoint:
    lat: float
    lon: float
    alt: float = 0.0

@dataclass
class EphemResult:
    lon: float
    lat: float
    dist: float
    speed_lon: float
    precision: PrecisionTag

class BaseEphemeris:
    def set_ayanamsa(self, ayanamsa: str) -> None:
        pass
    def planet_longitude(self, when: dt.datetime, planet: str, geo: Optional[GeoPoint], ayanamsa: str) -> EphemResult:
        raise NotImplementedError
    def ascendant(self, when: dt.datetime, geo: GeoPoint, ayanamsa: str) -> Optional[float]:
        raise NotImplementedError

SUPPORTED_PLANETS = {
    "SUN": 0, "MOON": 1, "MERCURY": 2, "VENUS": 3, "MARS": 4,
    "JUPITER": 5, "SATURN": 6, "URANUS": 7, "NEPTUNE": 8, "PLUTO": 9,
    "RAHU": "RAHU", "KETU": "KETU"
}

class SwissEphemerisProvider(BaseEphemeris):
    def __init__(self, eph_path: Optional[str] = None, ayanamsa: str = "lahiri"):
        if not _HAS_SWE:
            raise RuntimeError("Swiss Ephemeris not available")
        if eph_path:
            if not os.path.isdir(eph_path):
                raise FileNotFoundError(f"Swiss ephemeris path not found: {eph_path}")
            swe.set_ephe_path(eph_path)
        self.set_ayanamsa(ayanamsa)

    def set_ayanamsa(self, ayanamsa: str) -> None:
        mapping = {
            "lahiri": getattr(swe, "SIDM_LAHIRI", 1),
            "raman": getattr(swe, "SIDM_RAMAN", 15),
            "krishnamurti": getattr(swe, "SIDM_KRISHNAMURTI", 27),
            "fagan": getattr(swe, "SIDM_FAGAN_BRADLEY", 0),
        }
        swe.set_sid_mode(mapping.get(ayanamsa.lower(), getattr(swe, "SIDM_LAHIRI", 1)))

    def _jd_ut(self, when: dt.datetime) -> float:
        utc = when.astimezone(dt.timezone.utc)
        return swe.julday(utc.year, utc.month, utc.day, utc.hour + utc.minute/60 + utc.second/3600)

    def planet_longitude(self, when: dt.datetime, planet: str, geo: Optional[GeoPoint], ayanamsa: str) -> EphemResult:
        jd_ut = self._jd_ut(when)
        flag = swe.FLG_SWIEPH | swe.FLG_SPEED | swe.FLG_SIDEREAL
        if planet.upper() in ("RAHU","KETU"):
            pos, ret = swe.calc_ut(jd_ut, swe.MEAN_NODE, flag)  # TRUE_NODE if preferred
            if ret < 0:
                raise RuntimeError(f"swe.calc_ut node error: {ret}")
            lon = (pos[0] + (180.0 if planet.upper()=="KETU" else 0.0)) % 360.0
            return EphemResult(lon, pos[1], pos[2], pos[3], "high")
        pid = SUPPORTED_PLANETS[planet.upper()]
        pos, ret = swe.calc_ut(jd_ut, pid, flag)
        if ret < 0:
            raise RuntimeError(f"swe.calc_ut error: {ret}")
        return EphemResult(pos[0]%360, pos[1], pos[2], pos[3], "high")

    def ascendant(self, when: dt.datetime, geo: GeoPoint, ayanamsa: str) -> Optional[float]:
        try:
            jd_ut = self._jd_ut(when)
            # swe.houses returns (cusps, ascmc); ascmc[0] is Ascendant
            # Need geographic coords in degrees
            hsys = b'P'  # Placidus by default
            cusps, ascmc = swe.houses_ex(jd_ut, swe.FLG_SIDEREAL, geo.lat, geo.lon, hsys)
            asc = ascmc[0] % 360.0
            return asc
        except Exception:
            return None

class ApproxEphemerisProvider(BaseEphemeris):
    MEAN_MOTION = {
        "SUN": 0.985647, "MOON": 13.176358, "MERCURY": 4.092385, "VENUS": 1.602130,
        "MARS": 0.524039, "JUPITER": 0.083056, "SATURN": 0.033439,
        "URANUS": 0.011958, "NEPTUNE": 0.006886, "PLUTO": 0.004
    }
    def __init__(self, epoch: dt.datetime = dt.datetime(2000,1,1,12, tzinfo=dt.timezone.utc)):
        self.epoch = epoch

    def set_ayanamsa(self, ayanamsa: str) -> None:
        return

    def planet_longitude(self, when: dt.datetime, planet: str, geo: Optional[GeoPoint], ayanamsa: str) -> EphemResult:
        planet = planet.upper()
        days = (when.astimezone(dt.timezone.utc) - self.epoch).total_seconds()/86400.0
        if planet in ("RAHU","KETU"):
            rahu = (200.0 - 0.0529539*days) % 360
            lon = rahu if planet=="RAHU" else (rahu+180.0)%360
            return EphemResult(lon, 0.0, 1.0, -0.0529539, "coarse")
        rate = self.MEAN_MOTION.get(planet, 1.0)
        lon = (100.0 + rate*days) % 360.0
        return EphemResult(lon, 0.0, 1.0, rate, "coarse")

    def ascendant(self, when: dt.datetime, geo: GeoPoint, ayanamsa: str) -> Optional[float]:
        # Coarse fallback: derive asc from local sidereal approximation (very rough).
        # For UI placeholder only.
        return None

def get_ephemeris(ayanamsa: str = "lahiri") -> BaseEphemeris:
    eph_path = os.getenv("SE_EPHE_PATH") or os.getenv("SWISSEPH_PATH")
    if _HAS_SWE:
        try:
            return SwissEphemerisProvider(eph_path, ayanamsa=ayanamsa)
        except Exception as e:
            print(f"[warn] Swiss Ephemeris init failed: {e}; using ApproxEphemerisProvider")
    return ApproxEphemerisProvider()

# ------------------------------------------------------------
# 2) Input validation & context
# ------------------------------------------------------------

_TZ_RE = re.compile(r"^[+-](?:0\d|1[0-4]):?[0-5]\d$")  # ±00:00 .. ±14:00

@dataclass
class CalcContext:
    unknown_time: bool
    precision: str  # 'high'|'coarse'

def parse_tz_offset(tz: str) -> dt.tzinfo:
    tz = tz.strip()
    if not _TZ_RE.match(tz):
        raise ValueError("tz must be ±HH:MM or ±HHMM")
    if ":" not in tz:
        tz = tz[:3] + ":" + tz[3:]
    sign = 1 if tz[0] == "+" else -1
    th, tm = map(int, tz[1:].split(":"))
    return dt.timezone(dt.timedelta(hours=sign*th, minutes=sign*tm))

def build_local_dt(date_str: str, time_str: Optional[str], tz_str: str) -> Tuple[dt.datetime,bool]:
    y,m,d = map(int, date_str.split("-"))
    unknown = False
    if time_str:
        parts = list(map(int, time_str.split(":")))
        hh, mm = parts[0], parts[1]
    else:
        hh, mm = 12, 0
        unknown = True
    tzinfo = parse_tz_offset(tz_str)
    return dt.datetime(y,m,d,hh,mm,tzinfo=tzinfo), unknown

def guard_geo(lat: float, lon: float) -> None:
    if not (-90.0 <= lat <= 90.0): raise ValueError("lat must be between -90 and 90")
    if not (-180.0 <= lon <= 180.0): raise ValueError("lon must be between -180 and 180")

# ------------------------------------------------------------
# 3) Vimshottari Dasha
# ------------------------------------------------------------

NAK_LEN = 13 + 20/60  # 13°20'
DASHA_SEQ = ["KETU","VENUS","SUN","MOON","MARS","RAHU","JUPITER","SATURN","MERCURY"]
DASHA_YEARS = {"KETU":7,"VENUS":20,"SUN":6,"MOON":10,"MARS":7,"RAHU":18,"JUPITER":16,"SATURN":19,"MERCURY":17}

@dataclass
class Period:
    lord: str
    start: dt.datetime
    end: dt.datetime
    level: int  # 1=Maha, 2=Antara, 3=Pratyantar

def _sign_idx(lon: float) -> int: return int(lon//30)%12
def _wrap(x: float) -> float: return x % 360.0

def _add_years(t: dt.datetime, years: float) -> dt.datetime:
    return t + dt.timedelta(days=years*365.2425)

def _nak_ruler(moon_lon: float) -> str:
    idx = int((_wrap(moon_lon)) // NAK_LEN) % 27
    return DASHA_SEQ[idx % 9]

def _nak_fraction(moon_lon: float) -> float:
    pos = (_wrap(moon_lon)) % NAK_LEN
    return pos / NAK_LEN

def compute_mahadasha_start(moon_lon: float, birth_utc: dt.datetime) -> Tuple[List[Period], int]:
    lord = _nak_ruler(moon_lon)
    progressed = _nak_fraction(moon_lon)
    remaining = 1.0 - progressed
    start = birth_utc
    first_end = _add_years(start, DASHA_YEARS[lord]*remaining)
    maha = [Period(lord, start, first_end, 1)]
    cursor = first_end
    i = (DASHA_SEQ.index(lord)+1) % 9
    total = DASHA_YEARS[lord]*remaining
    while total < 120.0 + 0.001:
        L = DASHA_SEQ[i]
        dur = DASHA_YEARS[L]
        maha.append(Period(L, cursor, _add_years(cursor, dur), 1))
        cursor = maha[-1].end
        total += dur
        i = (i+1) % 9
    return maha, DASHA_SEQ.index(lord)

def subdivide(parent: Period, level=2) -> List[Period]:
    out = []
    cursor = parent.start
    parent_years = (parent.end - parent.start).total_seconds()/86400.0/365.2425
    for L in DASHA_SEQ:
        frac = DASHA_YEARS[L]/DASHA_YEARS[parent.lord]
        dur = parent_years * frac
        end = _add_years(cursor, dur)
        out.append(Period(L, cursor, end, level))
        cursor = end
    return out

def full_vimshottari(moon_lon: float, birth_utc: dt.datetime, depth: int = 3) -> List[Period]:
    maha,_ = compute_mahadasha_start(moon_lon, birth_utc)
    periods = []
    for m in maha:
        periods.append(m)
        if depth >= 2:
            antara = subdivide(m, 2)
            periods.extend(antara)
            if depth >= 3:
                for a in antara:
                    periods.extend(subdivide(a, 3))
    return periods

# ------------------------------------------------------------
# 4) Vargas (D9, D10)
# ------------------------------------------------------------

SIGNS = ["AR","TA","GE","CA","LE","VI","LI","SC","SG","CP","AQ","PI"]

def _sign_name(idx: int) -> str: return SIGNS[idx%12]

def d9_sign_index(lon: float) -> int:
    s = _sign_idx(lon); pos = _wrap(lon)%30.0; pada = int(pos // (30.0/9.0))
    starts = {0:0,4:0,8:0, 1:9,5:9,9:9, 2:6,6:6,10:6, 3:3,7:3,11:3}
    return (starts[s] + pada) % 12

def d10_sign_index(lon: float) -> int:
    s = _sign_idx(lon); pos = _wrap(lon)%30.0; decan = int(pos // 3.0)
    if s % 2 == 0:  # AR=0 treated as odd sign in tradition; index even => odd sign
        start = s
    else:
        start = (s + 8) % 12  # 9th
    return (start + decan) % 12

# ------------------------------------------------------------
# 5) Vedic aspects (graha drishti)
# ------------------------------------------------------------

SPECIAL_ASP = {"MARS":[90,240], "JUPITER":[120,300], "SATURN":[60,270]}
ALL_PLANETS = ("SUN","MOON","MERCURY","VENUS","MARS","JUPITER","SATURN","RAHU","KETU")

def _deg_delta(a: float, b: float) -> float:
    return abs((_wrap(a-b)+180)%360 - 180)

def graha_drishti(planet_lons: Dict[str,float], orb_deg: float = 3.0) -> List[Tuple[str,str,str,float]]:
    out = []
    items = list(planet_lons.items())
    for i,(p,lp) in enumerate(items):
        target_7th = _wrap(lp+180)
        for j,(q,lq) in enumerate(items):
            if i==j: continue
            d = _deg_delta(target_7th, lq)
            if d <= orb_deg:
                out.append((p,q,"7th",d))
        for ang in SPECIAL_ASP.get(p, []):
            anglon = _wrap(lp+ang)
            for j,(q,lq) in enumerate(items):
                if i==j: continue
                d = _deg_delta(anglon, lq)
                if d <= orb_deg:
                    out.append((p,q,"special",d))
    return out

# ------------------------------------------------------------
# 6) Arudha padas
# ------------------------------------------------------------

def arudha_pada(lagna_sign_idx: int, house_offset: int, lord_sign_idx: int) -> int:
    house_sign = (lagna_sign_idx + house_offset) % 12
    dist = (lord_sign_idx - house_sign) % 12
    if dist == 0: dist = 12
    target = (lord_sign_idx + dist) % 12
    if target == house_sign or target == (house_sign + 6) % 12:
        target = (target + 10) % 12
    return target

# ------------------------------------------------------------
# 7) Transits + Ingresse + Exact Solar Return
# ------------------------------------------------------------

ASPECT_DEGS = {"conjunction":0.0, "sextile":60.0, "square":90.0, "trine":120.0, "opposition":180.0}

@dataclass
class TransitEvent:
    when: dt.datetime
    mover: str
    target: str
    event: str
    exact_delta: float
    meta: Dict[str,Any]

def _angle_delta(a: float, b: float) -> float:
    d = (b - a + 180.0) % 360.0 - 180.0
    return d

def _refine_time(f: Callable[[dt.datetime], float], t1: dt.datetime, t2: dt.datetime, tol_sec=30) -> Tuple[dt.datetime,float]:
    v1, v2 = f(t1), f(t2)
    lo, hi = (t1, t2) if v1 < 0 else (t2, t1)
    while (hi - lo).total_seconds() > tol_sec:
        mid = lo + (hi - lo)/2
        vm = f(mid)
        if vm == 0: return mid, 0.0
        if vm < 0: lo = mid
        else: hi = mid
    mid = lo + (hi - lo)/2
    return mid, abs(f(mid))

def find_transit_aspects(
    eph: BaseEphemeris,
    natal_points: Dict[str,float],
    movers: Iterable[str],
    targets: Iterable[str],
    start: dt.datetime,
    end: dt.datetime,
    step_minutes: int = 60,
    orb_deg: float = 1.0,
    ayanamsa: str = "lahiri",
    geo: Optional[GeoPoint] = None
) -> List[TransitEvent]:
    events = []
    t = start
    target_lon = {tgt: _wrap(natal_points[tgt]) for tgt in targets}
    prev_vals: Dict[Tuple[str,str,str], Tuple[dt.datetime,float]] = {}
    while t <= end:
        for mover in movers:
            mv = eph.planet_longitude(t, mover, geo, ayanamsa).lon
            for tgt, lon_t in target_lon.items():
                for name,deg in ASPECT_DEGS.items():
                    key = (mover,tgt,name)
                    val = _angle_delta(_wrap(mv - lon_t), deg)
                    prev = prev_vals.get(key)
                    if prev is not None:
                        t_prev, v_prev = prev
                        if (v_prev <= 0 < val) or (v_prev >= 0 > val):
                            def f(tt): 
                                mm = eph.planet_longitude(tt, mover, geo, ayanamsa).lon
                                return _angle_delta(_wrap(mm - lon_t), deg)
                            when, err = _refine_time(f, t_prev, t, 30)
                            if abs(err) <= orb_deg:
                                events.append(TransitEvent(when, mover, tgt, name, abs(err), {"orb":orb_deg}))
                    prev_vals[key] = (t, val)
        t += dt.timedelta(minutes=step_minutes)
    events.sort(key=lambda e: e.when)
    return events

def find_ingresses(
    eph: BaseEphemeris,
    movers: Iterable[str],
    start: dt.datetime,
    end: dt.datetime,
    step_minutes: int = 30,
    ayanamsa: str = "lahiri",
    geo: Optional[GeoPoint] = None
) -> List[TransitEvent]:
    events = []
    last_sign: Dict[str,int] = {}
    def sidx(lon): return int(_wrap(lon)//30)
    t = start
    while t <= end:
        for mover in movers:
            lon = eph.planet_longitude(t, mover, geo, ayanamsa).lon
            s = sidx(lon)
            if mover in last_sign and s != last_sign[mover]:
                t_prev = t - dt.timedelta(minutes=step_minutes)
                # simple refine by binary search on sign change
                def g(tt):
                    return 0.5 if sidx(eph.planet_longitude(tt, mover, geo, ayanamsa).lon)==s else -0.5
                when, err = _refine_time(g, t_prev, t, 10)
                events.append(TransitEvent(when, mover, f"SIGN_{s}", "ingress", err, {"sign": s}))
            last_sign[mover] = s
        t += dt.timedelta(minutes=step_minutes)
    events.sort(key=lambda e: e.when)
    return events

def exact_solar_return(eph: BaseEphemeris, natal_sun_lon: float, approx_bday_local: dt.datetime, ayanamsa: str="lahiri", geo: Optional[GeoPoint]=None) -> dt.datetime:
    mid = approx_bday_local.astimezone(dt.timezone.utc)
    t1 = mid - dt.timedelta(days=2)
    t2 = mid + dt.timedelta(days=2)
    def f(t: dt.datetime) -> float:
        lon = eph.planet_longitude(t, "SUN", geo, ayanamsa).lon
        return (lon - natal_sun_lon + 180.0) % 360.0 - 180.0
    step = dt.timedelta(hours=6)
    a, b = t1, t1 + step
    fa = f(a)
    while b <= t2:
        fb = f(b)
        if (fa <= 0 < fb) or (fa >= 0 > fb):
            return _refine_time(f, a, b, 5)[0]
        a, b, fa = b, b + step, fb
    # fallback refine
    return _refine_time(f, t1, t2, 5)[0]

# ------------------------------------------------------------
# 8) Ashtakavarga (Bhina + Sarva)
# ------------------------------------------------------------

BINDU_OFFSETS = {
    "SUN":     [1,2,4,7,8,9,10,11],
    "MOON":    [3,6,7,10,11,12],
    "MARS":    [3,5,6,10,11],
    "MERCURY": [1,2,4,6,8,10,11,12],
    "JUPITER": [5,6,9,11,12],
    "VENUS":   [1,2,3,4,8,11,12],
    "SATURN":  [3,5,6,10,11],
}
LAGNA_OFFSETS = [3,6,10,11]

def planet_binna_ashtakavarga(planet: str, planet_lon: float) -> List[int]:
    points = [0]*12
    src = _sign_idx(planet_lon)
    for off in BINDU_OFFSETS[planet]:
        points[(src + off) % 12] = 1
    return points

def lagna_binna_ashtakavarga(lagna_sign_idx: int) -> List[int]:
    points = [0]*12
    for off in LAGNA_OFFSETS:
        points[(lagna_sign_idx + off) % 12] = 1
    return points

def sarva_ashtakavarga(natal_longitudes: Dict[str,float], lagna_sign_idx: Optional[int], include_lagna: bool=True) -> Dict[str, Any]:
    planet_binna: Dict[str,List[int]] = {}
    for p in ["SUN","MOON","MARS","MERCURY","JUPITER","VENUS","SATURN"]:
        planet_binna[p] = planet_binna_ashtakavarga(p, natal_longitudes[p])
    if include_lagna and lagna_sign_idx is not None:
        planet_binna["LAGNA"] = lagna_binna_ashtakavarga(lagna_sign_idx)
    sav = [0]*12
    for arr in planet_binna.values():
        for i,v in enumerate(arr): sav[i]+=v
    return {"planet_binna": planet_binna, "SAV": sav, "totals": {k: sum(v) for k,v in planet_binna.items()}}

# ------------------------------------------------------------
# 9) Varshaphal core
# ------------------------------------------------------------

TAJIKA_ASPECTS = ASPECT_DEGS

def _tajika_pairs(planet_lons: Dict[str,float], orb=3.0) -> List[Tuple[str,str,str,float]]:
    out=[]
    items=list(planet_lons.items())
    for i,(p,lp) in enumerate(items):
        for j in range(i+1,len(items)):
            q,lq=items[j]
            for name,deg in TAJIKA_ASPECTS.items():
                d=_deg_delta((lp-lq)%360,deg)
                if d<=orb:
                    out.append((p,q,name,d))
    return out

@dataclass
class VarshaResult:
    year: int
    solar_return_utc: dt.datetime
    muntha_sign_idx: int
    varsha_lagna_sign_idx: Optional[int]
    tajika_aspects: List[Tuple[str,str,str,float]]

def varshaphal_for_year(
    eph: BaseEphemeris,
    birth_local: dt.datetime,
    natal_sun_lon: float,
    year: int,
    ayanamsa: str = "lahiri",
    location: Optional[GeoPoint] = None,
    natal_lagna_sign_idx: Optional[int] = None
) -> VarshaResult:
    approx_bday_local = birth_local.replace(year=year)
    sr_utc = exact_solar_return(eph, natal_sun_lon, approx_bday_local, ayanamsa, location)
    planets = ["SUN","MOON","MERCURY","VENUS","MARS","JUPITER","SATURN","RAHU","KETU"]
    lons = {p: eph.planet_longitude(sr_utc, p, location, ayanamsa).lon for p in planets}
    asc_lon = None
    if location is not None:
        asc_lon = eph.ascendant(sr_utc, location, ayanamsa)
    varsha_lagna_sign = _sign_idx(asc_lon) if asc_lon is not None else _sign_idx(lons["SUN"])  # fallback
    completed_years = year - birth_local.year
    muntha = ((natal_lagna_sign_idx or 0) + completed_years) % 12
    tajika = _tajika_pairs(lons, orb=3.0)
    return VarshaResult(year, sr_utc, muntha, varsha_lagna_sign, tajika)

# ------------------------------------------------------------
# 10) Yoga engine (rule DSL)
# ------------------------------------------------------------

DEBILITATION = {"SUN":6,"MOON":8,"MARS":6,"MERCURY":11,"JUPITER":9,"VENUS":11,"SATURN":1}

@dataclass
class YogaHit:
    name: str
    score: float
    evidence: Dict[str,Any]

def _kendra_idxs(idx: int) -> List[int]:
    return [idx, (idx+3)%12, (idx+6)%12, (idx+9)%12]

def has_aspect(aspect_hits: List[Tuple[str,str,str,float]], src: str, dst: str, kinds=("7th","special")) -> bool:
    for s,t,k,_ in aspect_hits:
        if s==src and t==dst and k in kinds: return True
    return False

def evaluate_rules(
    rules: List[Dict[str,Any]],
    lons: Dict[str,float],
    aspects: List[Tuple[str,str,str,float]],
    varga_signs: Optional[Dict[str, Dict[str,str]]] = None,
    sav: Optional[List[int]] = None
) -> List[YogaHit]:
    hits: List[YogaHit] = []
    sidx = {p: _sign_idx(lon) for p,lon in lons.items()}
    for r in rules:
        ok = True
        ev = {}
        cond = r.get("when", {})
        for p, c in cond.items():
            if "in_sign" in c:
                target = c["in_sign"]
                if sidx[p] != target: ok=False; break
                ev[f"{p}.in_sign"]=True
            if c.get("not_debilitated"):
                if sidx[p] == DEBILITATION.get(p, -1): ok=False; break
                ev[f"{p}.not_debilitated"]=True
            if "in_kendra_from" in c:
                ref = c["in_kendra_from"]
                if sidx[p] not in _kendra_idxs(sidx[ref]): ok=False; break
                ev[f"{p}.kendra_from_{ref}"]=True
            if "has_aspect_on" in c:
                dst = c["has_aspect_on"]
                if not has_aspect(aspects, p, dst): ok=False; break
                ev[f"{p}.aspects_{dst}"]=True
            if "sav_min" in c and sav is not None:
                if sav[sidx[p]] < c["sav_min"]: ok=False; break
                ev[f"SAV[{sidx[p]}]>=min"]=True
            if "in_varga_sign" in c and varga_signs is not None:
                chart = c["in_varga_sign"]["chart"]
                sign = c["in_varga_sign"]["sign"]
                if varga_signs.get(chart, {}).get(p) != sign: ok=False; break
                ev[f"{p}.{chart}=={sign}"]=True
        if ok:
            hits.append(YogaHit(r["name"], r.get("score",1.0), {"explain": r.get("explain",""), **ev}))
    return hits

# ------------------------------------------------------------
# 11) Orchestrator
# ------------------------------------------------------------

class PredictionEngine:
    def __init__(self, ayanamsa: str = "lahiri"):
        self.ayanamsa = ayanamsa
        self.eph = get_ephemeris(ayanamsa)

    # --- core utils ---
    def _context(self, planets: Dict[str,Dict[str,Any]], unknown_time: bool) -> CalcContext:
        precision = "coarse" if any(p.get("precision")=="coarse" for p in planets.values()) else "high"
        return CalcContext(unknown_time=unknown_time, precision=precision)

    def compute_natal(self, date: str, time_str: Optional[str], tz: str, lat: float, lon: float, alt: float=0.0) -> Dict[str,Any]:
        guard_geo(lat, lon)
        local_dt, unknown = build_local_dt(date, time_str, tz)
        geo = GeoPoint(lat, lon, alt)
        planets = {}
        for name in ("SUN","MOON","MERCURY","VENUS","MARS","JUPITER","SATURN","URANUS","NEPTUNE","PLUTO","RAHU","KETU"):
            res = self.eph.planet_longitude(local_dt, name, geo, self.ayanamsa)
            planets[name] = {"lon": res.lon, "lat": res.lat, "speed": res.speed_lon, "precision": res.precision}
        asc = self.eph.ascendant(local_dt, geo, self.ayanamsa) if not unknown else None
        lagna_sign_idx = _sign_idx(asc) if asc is not None else None
        ctx = self._context(planets, unknown)
        return {"datetime": local_dt.isoformat(), "geo": geo.__dict__, "planets": planets, "ascendant": asc, "lagna_sign_idx": lagna_sign_idx, "context": ctx.__dict__}

    def compute_vargas(self, planets_lons: Dict[str,float]) -> Dict[str, Dict[str,str]]:
        d9 = {p: _sign_name(d9_sign_index(lon)) for p,lon in planets_lons.items()}
        d10 = {p: _sign_name(d10_sign_index(lon)) for p,lon in planets_lons.items()}
        return {"D9": d9, "D10": d10}

    def compute_aspects(self, planets_lons: Dict[str,float], orb=3.0) -> List[Tuple[str,str,str,float]]:
        return graha_drishti(planets_lons, orb)

    def compute_dasha(self, moon_lon: float, birth_local_dt: dt.datetime, tz: str, depth=3) -> List[Dict[str,Any]]:
        # Work in UTC
        birth_utc = birth_local_dt.astimezone(dt.timezone.utc)
        periods = full_vimshottari(moon_lon, birth_utc, depth=depth)
        return [{"lord": p.lord, "start": p.start.isoformat(), "end": p.end.isoformat(), "level": p.level} for p in periods]

    def compute_transits(self, natal_points: Dict[str,float], movers: Iterable[str], start: dt.datetime, end: dt.datetime, step_minutes=60, orb_deg=1.0, geo: Optional[GeoPoint]=None) -> List[Dict[str,Any]]:
        evs = find_transit_aspects(self.eph, natal_points, movers, natal_points.keys(), start, end, step_minutes, orb_deg, self.ayanamsa, geo)
        return [e.__dict__ for e in evs]

    def compute_solar_return(self, natal_sun_lon: float, approx_bday_local: dt.datetime, geo: Optional[GeoPoint]=None) -> str:
        sr = exact_solar_return(self.eph, natal_sun_lon, approx_bday_local, self.ayanamsa, geo)
        return sr.isoformat()

    def compute_ashtakavarga(self, natal_lons: Dict[str,float], lagna_sign_idx: Optional[int]) -> Dict[str,Any]:
        return sarva_ashtakavarga(natal_lons, lagna_sign_idx)

    def compute_varshaphal(self, birth_local_dt: dt.datetime, natal_sun_lon: float, year: int, geo: Optional[GeoPoint], natal_lagna_sign_idx: Optional[int]) -> Dict[str,Any]:
        v = varshaphal_for_year(self.eph, birth_local_dt, natal_sun_lon, year, self.ayanamsa, geo, natal_lagna_sign_idx)
        return {"year": v.year, "solar_return_utc": v.solar_return_utc.isoformat(), "muntha_sign_idx": v.muntha_sign_idx, "varsha_lagna_sign_idx": v.varsha_lagna_sign_idx, "tajika_aspects": v.tajika_aspects}

    def evaluate_yogas(self, rules: List[Dict[str,Any]], planets_lons: Dict[str,float], aspects: List[Tuple[str,str,str,float]], varga_signs: Optional[Dict[str, Dict[str,str]]] = None, sav: Optional[List[int]] = None) -> List[Dict[str,Any]]:
        hits = evaluate_rules(rules, planets_lons, aspects, varga_signs, sav)
        return [h.__dict__ for h in hits]

# End of file
